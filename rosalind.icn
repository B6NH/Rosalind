
# -------------------------------------------------------------------

procedure FIBO()

  input := 6

  arr := [0, 1] ; input +:= 1

  if 3 > input then

    write(arr[input])

  else {

    every 3 to input do {
      nxt := arr[1] + arr[2]
      arr[1] := arr[2]
      arr[2] := nxt
    }

    write(arr[2])

  }

end

# -------------------------------------------------------------------

procedure BINS()

  # Read input
  f := open("bins.txt","r")
  n := integer(read(f)) ; m := integer(read(f))
  sorted := lineToInts(read(f))
  ints := lineToInts(read(f))
  close(f)

  every writes(binS(ints[1 to m], sorted, n), " ")
  write()

end

procedure binS(el, lst, maxI)

  minI := 1

  if el < lst[minI] | el > lst[maxI] then {
    return -1
  } else {

    while minI <= maxI do {

      midI := minI + (maxI - minI) / 2

      if el = lst[midI] then {
        return midI
      } else if el < lst[midI] then {
        maxI := midI - 1
      } else {
        minI := midI + 1
      }

    }

    return -1

  }

end

procedure lineToInts(line)

  ints := [] ; s := &digits ++ '-'

  line ?
    while tab(upto(s)) do
      put(ints,integer(tab(many(s))))

  return ints

end

# -------------------------------------------------------------------

procedure DEG()

  f := open("deg.txt","r")

  # Vertices and edges
  ves := lineToInts(read(f))

  # Collect edges
  edges := []
  while push(edges,lineToInts(read(f)))

  close(f)

  # Initialize array for all vertices
  t := list(ves[1], 0)

  # Count occurrences
  every t[(!edges)[1 to 2]] +:= 1

  # Display result
  every writes(t[1 to ves[1]]," ")

  write()

end

# -------------------------------------------------------------------

procedure INS()

  # Read data
  f := open("ins.txt","r")
  n := lineToInts(read(f))[1]
  arr := lineToInts(read(f))
  close(f)

  swap := 0
  every i := 1 to n do {
    k := i
    while k > 1 & arr[k] < arr[k - 1] do {
      arr[k] :=: arr[k - 1]
      k -:= 1
    }
    swap +:= i - k
  }

  # Sorted array
  every writes(!arr," ") ; write()

  # Number of swaps
  write(swap)

end

# -------------------------------------------------------------------

procedure DDEG()

  # Read data
  f := open("ddeg.txt", "r")
  ves := lineToInts(read(f))
  edges := []
  while put(edges, lineToInts(read(f)))
  close(f)

  # Create adjacency list
  adjList := list(ves[1])
  every !adjList := []
  every e := !edges do {
    push(adjList[e[1]], e[2])
    push(adjList[e[2]], e[1])
  }

  # Create occurrences list
  occurrences := list(ves[1], 0)
  every occurrences[(!edges)[1 to 2]] +:= 1

  # Vertices
  every i := 1 to ves[1] do {

    # Sum occurrences of all neighbours
    sum := 0
    every sum +:= occurrences[!adjList[i]]
    writes(sum, " ")

  }

  write()

end

# -------------------------------------------------------------------

procedure MAJ()

  # Read data
  f := open("maj.txt", "r")
  fst := lineToInts(read(f))
  every !(arrays := list(fst[1])) := lineToInts(read(f))
  close(f)

  # Half array
  h := fst[2] / 2

  # Arrays
  every a := !arrays do {

    # Occurrences
    t := table(0)
    every t[!a] +:= 1

    # Max occurrences
    maxKey := ""
    every k := key(t) do
      t[k] > t[maxKey] & maxKey := k

    # Element or -1
    writes((t[maxKey] > h & maxKey) | -1, " ")

  }

  write()

end

# -------------------------------------------------------------------

procedure MER()

  f := open("mer.txt", "r")
  n := lineToInts(read(f))[1]
  a := lineToInts(read(f))
  m := lineToInts(read(f))[1]
  b := lineToInts(read(f))
  close(f)

  arr := merge(a, b, n, m)

  # Sorted array
  every writes(!arr, " ")
  write()

end

procedure merge(a, b, n, m)

   # Total length
  tLen := n + m

  # Copy elements
  arr := list(tLen)
  iA := 1 ; iB := 1
  every i := 1 to tLen do
    (iA > n | b[iB] < a[iA] & arr[i] := b[iB] & iB +:= 1) |
    (arr[i] := a[iA] & iA +:= 1)

  return arr

end

# -------------------------------------------------------------------

procedure MS()

  f := open("ms.txt","r")
  size := lineToInts(read(f))[1]
  arr := lineToInts(read(f))
  close(f)

  arr := mSort(arr, size)
  every writes(!arr," ")
  write()

end

procedure mSort(lst, size)

  if 1 = size then {
    return lst
  } else {

    sh2 := size - (sh1 := (h := size / 2 + 1) - 1)
    return merge(mSort(lst[1:h], sh1), mSort(lst[h:0], sh2), sh1, sh2)

  }

end

# -------------------------------------------------------------------

procedure SUM2()

  f := open("sum2.txt","r")
  fst := lineToInts(read(f))
  k := fst[1] ; n := fst[2]
  arrays := list(k)
  every i := 1 to k do
    arrays[i] := lineToInts(read(f))
  close(f)

  version := 2

  # Original version
  if 1 = version then {

    every array := !arrays do {
      str := "-1"
      every f := 1 to n - 1 do {
        every s := f + 1 to n do
          -1 * array[f] = array[s] & str := f || " " || s & break
        "-1" ~== str & break
      }
      write(str)
    }

  # Version based on explanation
  } else {

    every lst := !arrays do {

      t := table(0)
      every i := 1 to n do t[lst[i]] := i

      str := "-1" ; zeros := []
      every i := 1 to n do {
        if 0 = lst[i] then
          put(zeros,i) & 2 = *zeros & str := zeros[1] || " " || zeros[2] & break
        else
          other := -lst[i] & 0 ~= t[other] & str := i || " " || t[other] & break
      }

      write(str)

    }

  }

end

# -------------------------------------------------------------------

procedure BFS()

  # Read data
  f := open("bfs.txt","r")
  fst := lineToInts(read(f))
  n := fst[1]
  edges := []
  while put(edges,lineToInts(read(f)))
  close(f)

  # Table with lists of next vertices
  outs := table()
  every outs[1 to n] := []
  every e := !edges do push(outs[e[1]],e[2])

  # Start with 0 distance at vertex 1
  cDistance := 0 ; vertices := [1]

  # Initialize table of distances
  distances := table()

  # Loop until there are no more unknown vertices
  while not(allKnown(vertices,distances)) do {

    # Set distance for new vertices
    every /distances[!vertices] := cDistance

    # Collect next vertices in set
    newVertices := set()
    every insert(newVertices,!outs[!vertices])

    # Update vertices
    vertices := newVertices

    # Increase distance
    cDistance +:= 1

  }

  # Result
  every i := 1 to n do
    writes(\distances[i] | -1," ")

  write()

end

procedure allKnown(vertices,distances)
  every v := !vertices do
    member(distances,v) | fail
  return 1
end

# -------------------------------------------------------------------

procedure PPER()

  n := 21 ; k := 7 ; m := 1000000

  p := 1 ; nk := n - k + 1
  every p *:= (n to nk by -1) & p %:= m

  write(p)

end


# -------------------------------------------------------------------

procedure LEXF()

  # Data
  f := open("lexf.txt","r")
  al := read(f)
  n := lineToInts(read(f))[1]
  close(f)

  # Alphabet without whitespaces
  al ?:= {
    l := ""
    while tab(upto(&letters)) do
      l ||:= tab(many(&letters))
    l
  }

  every write(!lex(n,al))

end

procedure lex(level,al)

  if 1 = level then {

    return al

  } else {

    words := []

    every put(words, !al || !(lex(level - 1, al)))

    return words

  }

end

# -------------------------------------------------------------------

procedure REVP()
end

# -------------------------------------------------------------------

procedure LGIS()
end

# -------------------------------------------------------------------

procedure main()

  #FIBO()
  #BINS()
  #DEG()
  #INS()
  #DDEG()
  #MAJ()
  #MER()
  #MS()
  #SUM2()
  #BFS()
  #PPER()
  #LEXF()
  REVP()

end

# -------------------------------------------------------------------
